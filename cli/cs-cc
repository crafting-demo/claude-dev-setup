#!/usr/bin/env node

import { readFileSync, existsSync, writeFileSync, unlinkSync } from 'node:fs';
import { exec } from 'node:child_process';
import { fileURLToPath } from 'node:url';
import { dirname, resolve, isAbsolute } from 'node:path';

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

function parseArguments() {
  const args = process.argv.slice(2);
  const parsed = { d: 'yes' }; // Set default for delete-when-done
  
  for (let i = 0; i < args.length; i++) {
    const arg = args[i];
    
    if (arg === '--help') {
      parsed.help = true;
      continue;
    }
    
    // Handle arguments that need values
    if (arg.startsWith('-') && i + 1 < args.length) {
      const value = args[i + 1];
      
      switch (arg) {
        case '-p':
        case '--prompt':
          parsed.p = value;
          i++;
          break;
        case '-pool':
          parsed.pool = value;
          i++;
          break;
        case '-r':
        case '--repo':
          parsed.r = value;
          i++;
          break;
        case '-ght':
        case '--github-token':
          parsed.ght = value;
          i++;
          break;
        case '-pr':
        case '--pull-request':
          parsed.pr = value;
          i++;
          break;
        case '-i':
        case '--issue':
          parsed.i = value;
          i++;
          break;
        case '-b':
        case '--branch':
          parsed.b = value;
          i++;
          break;
        case '-mc':
        case '--mcp-config':
          parsed.mc = value;
          i++;
          break;
        case '-lmc':
        case '--local-mcp-config':
          parsed.lmc = value;
          i++;
          break;
        case '-t':
        case '--tools':
          parsed.t = value;
          i++;
          break;
        case '-d':
        case '--delete-when-done':
          parsed.d = value;
          i++;
          break;
        case '-n':
        case '--name':
          parsed.n = value;
          i++;
          break;
        default:
          throw new Error(`Unknown option: ${arg}`);
      }
    } else if (arg.startsWith('-')) {
      // Special case for dry-run flag that doesn't need a value
      if (arg === '--dry-run') {
        parsed.dryRun = true;
      } else {
        throw new Error(`Option ${arg} requires a value`);
      }
    } else {
      throw new Error(`Unexpected positional argument: ${arg}`);
    }
  }
  
  return parsed;
}

function showHelp() {
  console.log(`
cs-cc - Claude Sandbox Code CLI

Usage: cs-cc [options]

Options:
  -p, --prompt <value>           Prompt string or file path (required)
  -pool <name>                   Sandbox pool name (optional)
  -r, --repo <owner/repo>        GitHub repository (required for GitHub integration)
  -ght, --github-token <token>   GitHub access token (required for GitHub integration)
  -pr, --pull-request <number>   Pull request number (mutually exclusive with -i, -b)
  -i, --issue <number>           Issue number (mutually exclusive with -pr, -b)
  -b, --branch <name>            Branch name (mutually exclusive with -pr, -i)
  -mc, --mcp-config <value>      External MCP config string or file path (optional)
  -lmc, --local-mcp-config <value> Local MCP tools config string or file path (optional)
  -t, --tools <value>            Tool whitelist string or file path (optional)
  -d, --delete-when-done <yes|no> Delete sandbox when done (default: yes)
  -n, --name <name>              Sandbox name (default: auto-generated)
  --dry-run                      Validate parameters and show commands without execution
  --help                         Show this help message

Examples:
  cs-cc -p "Fix the login bug" -r "owner/repo" -ght "ghp_token" -pr 123
  cs-cc -p prompt.txt -r "owner/repo" -ght "ghp_token" -i 456 -mc external_mcp.txt
  cs-cc -p "Implement feature" -pool my-pool -lmc local_tools.txt -t tool_whitelist.txt
`);
}

function readFileOrString(value) {
  if (!value) return '';
  
  // Check if it's a file path
  const isFile = value.includes('/') || value.includes('\\') || value.endsWith('.txt') || value.endsWith('.json');
  
  if (isFile) {
    const filePath = isAbsolute(value) ? value : resolve(process.cwd(), value);
    if (!existsSync(filePath)) {
      throw new Error(`File not found: ${filePath}`);
    }
    return readFileSync(filePath, 'utf8').trim();
  }
  
  return value;
}

function validateJsonContent(content, parameterName) {
  if (!content) return content;
  
  try {
    JSON.parse(content);
    return content;
  } catch (error) {
    throw new Error(`Invalid JSON in ${parameterName}: ${error.message}`);
  }
}



function validateArgs(args) {
  const errors = [];
  
  // Validate required parameters
  if (!args.p) {
    errors.push('Prompt (-p) is required');
  }
  
  // Validate mutually exclusive GitHub parameters
  const githubParams = [args.pr, args.i, args.b].filter(Boolean);
  if (githubParams.length > 1) {
    errors.push('Only one of -pr, -i, or -b can be specified');
  }
  
  // Validate GitHub integration parameters
  if (args.r || args.ght || githubParams.length > 0) {
    if (!args.r) {
      errors.push('GitHub repo is required when using GitHub integration');
    } else {
      // Validate GitHub repository format (owner/repo)
      const repoPattern = /^[a-zA-Z0-9._-]+\/[a-zA-Z0-9._-]+$/;
      if (!repoPattern.test(args.r)) {
        errors.push('Invalid repo format - must be in format owner/repo');
      }
    }
    if (!args.ght) errors.push('GitHub token is required when using GitHub integration');
    if (githubParams.length === 0) {
      errors.push('One of -pr, -i, or -b must be specified when using GitHub integration');
    }
  }
  
  // Validate delete-when-done parameter
  if (args.d && !['yes', 'no'].includes(args.d.toLowerCase())) {
    errors.push('Delete when done (-d) must be "yes" or "no"');
  }
  
  if (errors.length > 0) {
    throw new Error('Validation errors:\n' + errors.map(e => `  - ${e}`).join('\n'));
  }
}

function generateSandboxName(args) {
  if (args.n) {
    return args.n;
  }
  
  // Use existing naming logic from agent.js with sanitization
  const repoName = args.r ? args.r.split('/')[1] || 'repo' : 'sandbox';
  const timestamp = Date.now().toString().slice(-4);
  const itemNumber = args.pr || args.i || 'dev';
  
  // Sanitize repo name - replace invalid characters with hyphens and ensure valid format
  const sanitizedRepoName = repoName
    .substring(0, 8)
    .replace(/[^a-z0-9-]/gi, '-')  // Replace invalid chars with hyphens
    .replace(/^[^a-z]/i, 'a')      // Ensure starts with letter
    .replace(/[^a-z0-9]$/i, '9')   // Ensure ends with letter or number
    .toLowerCase();
  
  const sandboxName = `cw-${sanitizedRepoName}-${itemNumber}-${timestamp}`.substring(0, 20);
  
  return sandboxName;
}

async function transferFile(content, sandboxName, targetPath, description) {
  if (!content) return;

  const tempFile = `./temp_${Date.now()}.txt`;

  try {
    // Write content to temporary file
    writeFileSync(tempFile, content, 'utf8');

    // -----------------------------------------------------------------------------------
    // Ensure destination directory exists inside the sandbox before attempting SCP
    // -----------------------------------------------------------------------------------
    const remoteDir = dirname(targetPath);
    const mkdirCmd = `cs exec -t -u 1000 -W ${sandboxName}/claude -- mkdir -p ${remoteDir}`;
    console.log(`Ensuring remote directory exists: ${remoteDir}`);

    await new Promise((resolve, reject) => {
      const child = exec(mkdirCmd, { timeout: 20000 });

      child.on('close', (code) => {
        if (code === 0) {
          resolve();
        } else {
          console.warn(`Directory creation command exited with code ${code} (dir may already exist)`);
          resolve(); // Proceed anyway; scp may still work if dir exists
        }
      });

      child.on('error', (error) => {
        console.warn(`Failed to create remote directory: ${error.message} (continuing anyway)`);
        resolve();
      });
    });

    // Transfer file to sandbox
    const scpCmd = `cs scp ${tempFile} ${sandboxName}/claude:${targetPath}`;
    console.log(`Transferring ${description} to sandbox path: ${targetPath}`);

    await new Promise((resolve, reject) => {
      const child = exec(scpCmd, { timeout: 30000 });

      child.stdout.on('data', (data) => {
        process.stdout.write(`[SCP] ${data}`);
      });

      child.stderr.on('data', (data) => {
        process.stderr.write(`[SCP] ${data}`);
      });

      child.on('close', (code) => {
        if (code === 0) {
          console.log(`${description} transfer completed successfully`);
          resolve({ code });
        } else {
          console.error(`${description} transfer failed with exit code: ${code}`);
          reject(new Error(`${description} transfer failed with exit code: ${code}`));
        }
      });

      child.on('error', (error) => {
        console.error(`${description} transfer failed: ${error.message}`);
        reject(error);
      });
    });

  } finally {
    // Clean up temporary file
    try {
      unlinkSync(tempFile);
    } catch (err) {
      console.warn(`Failed to clean up temporary file: ${err.message}`);
    }
  }
}

async function validateGitHubResources(args) {
  // Only validate if GitHub integration is being used
  if (!args.r || !args.ght) return;
  
  const repo = args.r;
  
  try {
    if (args.pr) {
      // Validate PR exists using gh CLI
      const result = await new Promise((resolve) => {
        const child = exec(`gh pr view ${args.pr} --repo ${repo}`, 
          { timeout: 10000, env: { ...process.env, GITHUB_TOKEN: args.ght } });
        
        child.on('close', (code) => {
          resolve({ code });
        });
        
        child.on('error', (error) => {
          resolve({ code: 1 });
        });
      });
      
      if (result.code !== 0) {
        throw new Error(`Pull request #${args.pr} does not exist in ${repo}`);
      }
    } else if (args.i) {
      // Validate issue exists using gh CLI
      const result = await new Promise((resolve) => {
        const child = exec(`GITHUB_TOKEN=${args.ght} gh issue view ${args.i} --repo ${repo} --json number`, 
          { timeout: 10000 });
        
        child.on('close', (code) => {
          resolve({ code });
        });
        
        child.on('error', () => {
          resolve({ code: 1 });
        });
      });
      
      if (result.code !== 0) {
        throw new Error(`Issue #${args.i} does not exist in ${repo}`);
      }
    } else if (args.b) {
      // Validate branch exists using gh CLI
      const result = await new Promise((resolve) => {
        const child = exec(`GITHUB_TOKEN=${args.ght} gh api repos/${repo}/branches/${args.b} --jq .name`, 
          { timeout: 10000 });
        
        child.on('close', (code) => {
          resolve({ code });
        });
        
        child.on('error', () => {
          resolve({ code: 1 });
        });
      });
      
      if (result.code !== 0) {
        throw new Error(`Branch '${args.b}' does not exist in ${repo}`);
      }
    }
  } catch (error) {
    if (error.message.includes('does not exist')) {
      throw error;
    }
    // For network errors or other issues, log warning but don't fail
    console.warn(`Warning: Could not validate GitHub resource: ${error.message}`);
  }
}

async function createSandbox(args) {
  try {
    // Validate arguments
    validateArgs(args);
    
    // Validate GitHub resources exist
    await validateGitHubResources(args);
    
    // Read file content for parameters that support files
    const prompt = readFileOrString(args.p);
    const mcpConfig = args.mc ? validateJsonContent(readFileOrString(args.mc), 'external MCP config (-mc)') : '';
    const localMcpConfig = args.lmc ? validateJsonContent(readFileOrString(args.lmc), 'local MCP config (-lmc)') : '';
    const toolWhitelist = args.t ? validateJsonContent(readFileOrString(args.t), 'tool whitelist (-t)') : '';
    
    // Generate sandbox name
    const sandboxName = generateSandboxName(args);
    console.log(`Creating sandbox: ${sandboxName}`);
    
    // Build sandbox creation command
    let cmd = `cs sandbox create ${sandboxName} -t claude-code-automation`;
    
    // Add pool option if specified
    if (args.pool) {
      cmd += ` --use-pool ${args.pool}`;
    }
    
    // Add environment variables
    const envVars = [];
    
    // GitHub integration variables
    if (args.r && args.ght) {
      envVars.push(`-D 'claude/env[GITHUB_REPO]=${args.r}'`);
      envVars.push(`-D 'claude/env[GITHUB_TOKEN]=${args.ght}'`);
      
      if (args.pr) {
        envVars.push(`-D 'claude/env[PR_NUMBER]=${args.pr}'`);
        envVars.push(`-D 'claude/env[ACTION_TYPE]=pr'`);
      } else if (args.i) {
        envVars.push(`-D 'claude/env[ISSUE_NUMBER]=${args.i}'`);
        envVars.push(`-D 'claude/env[ACTION_TYPE]=issue'`);
      } else if (args.b) {
        envVars.push(`-D 'claude/env[GITHUB_BRANCH]=${args.b}'`);
        envVars.push(`-D 'claude/env[ACTION_TYPE]=branch'`);
      }
    }
    
    // Sandbox lifecycle variables
    const shouldDelete = args.d.toLowerCase() === 'yes' ? 'true' : 'false';
    envVars.push(`-D 'claude/env[SHOULD_DELETE]=${shouldDelete}'`);
    
    // Add Anthropic API key
    envVars.push(`-D 'claude/env[ANTHROPIC_API_KEY]=\${secret:shared/anthropic-apikey-eng}'`);
    
    if (envVars.length > 0) {
      cmd += ' \\\n  ' + envVars.join(' \\\n  ');
    }
    
    console.log(`Executing sandbox creation command...`);
    console.log(`Command: ${cmd}`);
    
    // Check for dry-run mode
    if (args.dryRun) {
      console.log(`\n🔍 DRY RUN MODE - No actual sandbox creation or file transfers will occur\n`);
      
      // Show what files would be transferred
      console.log(`Files that would be transferred:`);
      console.log(`  📄 Prompt → /home/owner/cmd/prompt.txt`);
      if (mcpConfig) console.log(`  📄 External MCP config → /home/owner/cmd/external_mcp.txt`);
      if (localMcpConfig) console.log(`  📄 Local MCP tools → /home/owner/cmd/local_mcp_tools.txt`);
      if (toolWhitelist) console.log(`  📄 Tool whitelist → /home/owner/cmd/tool_whitelist.txt`);
      
      console.log(`\n✅ Parameter validation successful. Command would execute: ${cmd}`);
      console.log(`\n🚀 Dry run complete. Remove --dry-run flag to create actual sandbox.`);
      return;
    }
    
    // Execute sandbox creation
    await new Promise((resolve, reject) => {
      const child = exec(cmd, { timeout: 120000 });
      
      child.stdout.on('data', (data) => {
        process.stdout.write(data);
      });
      
      child.stderr.on('data', (data) => {
        process.stderr.write(data);
      });
      
      child.on('close', (code) => {
        if (code === 0) {
          console.log(`\nSandbox creation completed successfully`);
          resolve({ code });
        } else {
          console.error(`\nSandbox creation failed with exit code: ${code}`);
          reject(new Error(`Sandbox creation failed with exit code: ${code}`));
        }
      });
      
      child.on('error', (error) => {
        console.error(`\nSandbox creation failed: ${error.message}`);
        reject(error);
      });
    });
    
    console.log(`Sandbox is ready, proceeding with file transfers...`);
    
    // Transfer files to sandbox
    await transferFile(prompt, sandboxName, '/home/owner/cmd/prompt.txt', 'prompt');
    
    if (mcpConfig) {
      await transferFile(mcpConfig, sandboxName, '/home/owner/cmd/external_mcp.txt', 'external MCP config');
    }
    
    if (localMcpConfig) {
      await transferFile(localMcpConfig, sandboxName, '/home/owner/cmd/local_mcp_tools.txt', 'local MCP tools');
    }
    
    if (toolWhitelist) {
      await transferFile(toolWhitelist, sandboxName, '/home/owner/cmd/tool_whitelist.txt', 'tool whitelist');
    }
    
    console.log(`\n🚀 Sandbox "${sandboxName}" created successfully with all configurations!`);
    console.log(`\nNext steps:`);
    console.log(`  1. Connect to sandbox: cs ssh ${sandboxName}`);
    console.log(`  2. Initialize worker: ~/dev-worker/start-worker.sh`);
    
  } catch (error) {
    console.error(`❌ cs-cc failed: ${error.message}`);
    process.exit(1);
  }
}

// Main execution
async function main() {
  try {
    const args = parseArguments();
    
    if (args.help) {
      showHelp();
      process.exit(0);
    }
    
    await createSandbox(args);
    
  } catch (error) {
    console.error(`❌ ${error.message}`);
    process.exit(1);
  }
}

main(); 