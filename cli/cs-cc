#!/usr/bin/env node

import { readFileSync, existsSync, writeFileSync, unlinkSync, statSync, readdirSync } from 'node:fs';
import { exec } from 'node:child_process';
import { fileURLToPath } from 'node:url';
import { dirname, resolve, isAbsolute, join } from 'node:path';

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

function parseArguments() {
  const args = process.argv.slice(2);
  const parsed = { d: 'yes' }; // Set default for delete-when-done
  
  for (let i = 0; i < args.length; i++) {
    const arg = args[i];
    
    if (arg === '--help') {
      parsed.help = true;
      continue;
    }
    
    // Handle arguments that need values
    if (arg.startsWith('-') && i + 1 < args.length) {
      const value = args[i + 1];
      
      switch (arg) {
        case '-p':
        case '--prompt':
          parsed.p = value;
          i++;
          break;
        case '-pool':
          parsed.pool = value;
          i++;
          break;
        case '-r':
        case '--repo':
          parsed.r = value;
          i++;
          break;
        case '-ght':
        case '--github-token':
          parsed.ght = value;
          i++;
          break;
        case '-pr':
        case '--pull-request':
          parsed.pr = value;
          i++;
          break;
        case '-i':
        case '--issue':
          parsed.i = value;
          i++;
          break;
        case '-b':
        case '--branch':
          parsed.b = value;
          i++;
          break;
        case '-mc':
        case '--mcp-config':
          parsed.mc = value;
          i++;
          break;
        case '-ad':
        case '--agents-dir':
          parsed.ad = value;
          i++;
          break;
        case '-t':
        case '--tools':
          parsed.t = value;
          i++;
          break;
        case '-template':
        case '--template':
          parsed.template = value;
          i++;
          break;
        case '-d':
        case '--delete-when-done':
          parsed.d = value;
          i++;
          break;
        case '-n':
        case '--name':
          parsed.n = value;
          i++;
          break;
        case '--debug':
          parsed.debug = value;
          i++;
          break;
        case '-rp':
        case '--repo-path':
          parsed.rp = value;
          i++;
          break;
        case '--resume':
          parsed.resume = value;
          i++;
          break;
        case '-tid':
        case '--task-id':
          parsed.tid = value;
          i++;
          break;
        default:
          throw new Error(`Unknown option: ${arg}`);
      }
    } else if (arg.startsWith('-')) {
      // Special case for dry-run flag that doesn't need a value
      if (arg === '--dry-run') {
        parsed.dryRun = true;
      } else {
        throw new Error(`Option ${arg} requires a value`);
      }
    } else {
      throw new Error(`Unexpected positional argument: ${arg}`);
    }
  }
  
  return parsed;
}

function showHelp() {
  console.log(`
cs-cc - Claude Sandbox Code CLI

Usage: cs-cc [options]

Options:
  -p, --prompt <value>           Prompt string or file path (required)
  -pool <name>                   Sandbox pool name (optional)
  -r, --repo <owner/repo>        GitHub repository (required for GitHub integration)
  -ght, --github-token <token>   GitHub access token (optional, defaults to Crafting credentials)
  -pr, --pull-request <number>   Pull request number (mutually exclusive with -i, -b)
  -i, --issue <number>           Issue number (mutually exclusive with -pr, -b)
  -b, --branch <name>            Branch name (mutually exclusive with -pr, -i)
  -mc, --mcp-config <value>      External MCP config string or file path (optional)
  -ad, --agents-dir <path>       Directory containing individual agent JSON files (optional)
  -t, --tools <value>            Tool whitelist string or file path (optional)
  -template, --template <value>  Custom template name (default: claude-code-automation)
  -d, --delete-when-done <yes|no> Delete sandbox when done (default: yes)
  -n, --name <name>              Sandbox name (default: auto-generated)
  --resume <sandbox_name>        Resume existing sandbox with new task (skip creation)
  -tid, --task-id <id>           Custom task ID (optional, auto-generated if not provided)
  --debug <yes|no>               Debug mode: wait for worker completion and show all output (default: no)
  --dry-run                      Validate parameters and show commands without execution
  --help                         Show this help message

Examples:
  cs-cc -p "Fix the login bug" -r "owner/repo" -ght "ghp_token" -pr 123
  cs-cc -p prompt.txt -r "owner/repo" -ght "ghp_token" -i 456 -mc external_mcp.txt
  cs-cc -p "Fix bugs" -r "owner/repo" -ght "ghp_token" -pr 123 -ad ./agents
  cs-cc -p "Implement feature" -pool my-pool -ad ./agents -t tool_whitelist.txt
  cs-cc -p "Debug workflow" -r "owner/repo" -ght "token" -b main --debug yes
  cs-cc -p "Custom workflow" -template my-template -r "owner/repo" -ght "token" -b main
  cs-cc --resume my-sandbox -p "Follow-up task" -t new_tools.json -tid task-2
`);
}

function readFileOrString(value) {
  if (!value) return '';
  
  // Check if it's a file path
  const isFile = value.includes('/') || value.includes('\\') || value.endsWith('.txt') || value.endsWith('.json');
  
  if (isFile) {
    const filePath = isAbsolute(value) ? value : resolve(process.cwd(), value);
    if (!existsSync(filePath)) {
      throw new Error(`File not found: ${filePath}`);
    }
    return readFileSync(filePath, 'utf8').trim();
  }
  
  return value;
}

function processAgentsDirectory(dirPath) {
  if (!dirPath) return '';
  
  const resolvedPath = isAbsolute(dirPath) ? dirPath : resolve(process.cwd(), dirPath);
  if (!existsSync(resolvedPath)) {
    throw new Error(`Agents directory not found: ${resolvedPath}`);
  }
  
  // Check if it's actually a directory
  if (!statSync(resolvedPath).isDirectory()) {
    throw new Error(`Path is not a directory: ${resolvedPath}`);
  }
  
  // Read all .json files in the directory
  const agentFiles = readdirSync(resolvedPath)
    .filter(file => file.endsWith('.json'))
    .map(file => join(resolvedPath, file));
  
  if (agentFiles.length === 0) {
    console.log(`Warning: No JSON agent files found in directory: ${resolvedPath}`);
    return '[]';
  }
  
  console.log(`Processing ${agentFiles.length} agent files from ${resolvedPath}`);
  
  // Parse and combine all agent files into array
  const agents = [];
  for (const file of agentFiles) {
    try {
      const content = readFileSync(file, 'utf8');
      const agent = JSON.parse(content);
      
      // Validate required fields
      if (!agent.name || !agent.description || !agent.prompt) {
        throw new Error(`Agent file missing required fields (name, description, prompt): ${file}`);
      }
      
      agents.push(agent);
      console.log(`Added agent: ${agent.name}`);
    } catch (error) {
      throw new Error(`Error processing agent file ${file}: ${error.message}`);
    }
  }
  
  return JSON.stringify(agents, null, 2);
}

function validateJsonContent(content, parameterName) {
  if (!content) return content;
  
  try {
    JSON.parse(content);
    return content;
  } catch (error) {
    throw new Error(`Invalid JSON in ${parameterName}: ${error.message}`);
  }
}



function validateArgs(args) {
  const errors = [];
  
  // Validate required parameters
  if (!args.p) {
    errors.push('Prompt (-p) is required');
  }
  
  // Resume mode validation
  if (args.resume) {
    // In resume mode, validate sandbox name format
    const sandboxPattern = /^[a-zA-Z0-9._-]+$/;
    if (!sandboxPattern.test(args.resume)) {
      errors.push('Invalid sandbox name format - must contain only letters, numbers, dots, hyphens, and underscores');
    }
    
    // Resume mode has simplified requirements
    // Skip GitHub integration validation since sandbox already exists
    console.log('Resume mode detected - using simplified validation');
    
    // Basic sandbox existence check (simple validation)
    // Note: This is a basic check - actual sandbox state will be validated by start-worker.sh
    console.log(`Checking if sandbox '${args.resume}' is accessible...`);
    
    // Validate task ID if provided
    if (args.tid) {
      const taskIdPattern = /^[a-zA-Z0-9._-]+$/;
      if (!taskIdPattern.test(args.tid)) {
        errors.push('Invalid task ID format - must contain only letters, numbers, dots, hyphens, and underscores');
      }
    }
  } else {
    // Normal mode validation - existing GitHub integration validation
    // Validate mutually exclusive GitHub parameters
    const githubParams = [args.pr, args.i, args.b].filter(Boolean);
    if (githubParams.length > 1) {
      errors.push('Only one of -pr, -i, or -b can be specified');
    }
    
    // Validate GitHub integration parameters
    if (args.r || args.ght || githubParams.length > 0) {
      if (!args.r) {
        errors.push('GitHub repo is required when using GitHub integration');
      } else {
        // Validate GitHub repository format (owner/repo)
        const repoPattern = /^[a-zA-Z0-9._-]+\/[a-zA-Z0-9._-]+$/;
        if (!repoPattern.test(args.r)) {
          errors.push('Invalid repo format - must be in format owner/repo');
        }
      }
      // GitHub token is now optional - will use Crafting credentials as fallback
      if (githubParams.length === 0) {
        errors.push('One of -pr, -i, or -b must be specified when using GitHub integration');
      }
    }
  }
  
  // Validate delete-when-done parameter
  if (args.d && !['yes', 'no'].includes(args.d.toLowerCase())) {
    errors.push('Delete when done (-d) must be "yes" or "no"');
  }
  
  // Validate debug parameter
  if (args.debug && !['yes', 'no'].includes(args.debug.toLowerCase())) {
    errors.push('Debug mode (--debug) must be "yes" or "no"');
  }
  
  if (errors.length > 0) {
    throw new Error('Validation errors:\n' + errors.map(e => `  - ${e}`).join('\n'));
  }
}

function generateSandboxName(args) {
  if (args.n) {
    return args.n;
  }
  
  // Use existing naming logic from agent.js with sanitization
  const repoName = args.r ? args.r.split('/')[1] || 'repo' : 'sandbox';
  const timestamp = Date.now().toString().slice(-4);
  const itemNumber = args.pr || args.i || 'dev';
  
  // Sanitize repo name - replace invalid characters with hyphens and ensure valid format
  const sanitizedRepoName = repoName
    .substring(0, 8)
    .replace(/[^a-z0-9-]/gi, '-')  // Replace invalid chars with hyphens
    .replace(/^[^a-z]/i, 'a')      // Ensure starts with letter
    .replace(/[^a-z0-9]$/i, '9')   // Ensure ends with letter or number
    .toLowerCase();
  
  const sandboxName = `cw-${sanitizedRepoName}-${itemNumber}-${timestamp}`.substring(0, 20);
  
  return sandboxName;
}

async function transferFile(content, sandboxName, targetPath, description) {
  if (!content) return;

  const tempFile = `./temp_${Date.now()}.txt`;

  try {
    writeFileSync(tempFile, content, 'utf8');

    const remoteDir = dirname(targetPath);
    const mkdirCmdBase = `cs exec -t -u 1000 -W ${sandboxName}/claude -- mkdir -p ${remoteDir}`;
    const scpCmdBase   = `cs scp ${tempFile} ${sandboxName}/claude:${targetPath}`;

    // Helper to run a shell command with retries
    const runWithRetries = (cmd, maxRetries = 5, delayMs = 5000) => new Promise((resolve, reject) => {
      let attempt = 0;
      const run = () => {
        console.log(`Attempt #${attempt+1}: ${cmd}`);
        const child = exec(cmd, { timeout: 60000 });
        child.on('close', (code) => {
          if (code === 0) return resolve();
          if (++attempt >= maxRetries) return reject(new Error(`Command failed after ${maxRetries} attempts (exit ${code})`));
          console.warn(`Command failed (exit ${code}) ‚Äì retrying in ${delayMs/1000}s...`);
          setTimeout(run, delayMs);
        });
        child.on('error', (err) => {
          if (++attempt >= maxRetries) return reject(err);
          console.warn(`Command error: ${err.message} ‚Äì retrying in ${delayMs/1000}s...`);
          setTimeout(run, delayMs);
        });
      };
      run();
    });

    console.log(`Ensuring remote directory exists: ${remoteDir}`);
    await runWithRetries(mkdirCmdBase);

    console.log(`Transferring ${description} to sandbox path: ${targetPath}`);
    await runWithRetries(scpCmdBase);

    console.log(`${description} transfer completed successfully`);
  } finally {
    try { unlinkSync(tempFile); } catch {}
  }
}

async function validateGitHubResources(args) {
  // Only validate if GitHub integration is being used
  if (!args.r || !args.ght) return;
  
  const repo = args.r;
  
  try {
    if (args.pr) {
      // Validate PR exists using gh CLI
      const result = await new Promise((resolve) => {
        const env = { ...process.env };
        if (args.ght) {
          env.GITHUB_TOKEN = args.ght;
        }
        const child = exec(`gh pr view ${args.pr} --repo ${repo}`, 
          { timeout: 10000, env });
        
        child.on('close', (code) => {
          resolve({ code });
        });
        
        child.on('error', (error) => {
          resolve({ code: 1 });
        });
      });
      
      if (result.code !== 0) {
        throw new Error(`Pull request #${args.pr} does not exist in ${repo}`);
      }
    } else if (args.i) {
      // Validate issue exists using gh CLI
      const result = await new Promise((resolve) => {
        const env = { ...process.env };
        if (args.ght) {
          env.GITHUB_TOKEN = args.ght;
        }
        const child = exec(`gh issue view ${args.i} --repo ${repo} --json number`, 
          { timeout: 10000, env });
        
        child.on('close', (code) => {
          resolve({ code });
        });
        
        child.on('error', () => {
          resolve({ code: 1 });
        });
      });
      
      if (result.code !== 0) {
        throw new Error(`Issue #${args.i} does not exist in ${repo}`);
      }
    } else if (args.b) {
      // Validate branch exists using gh CLI
      const result = await new Promise((resolve) => {
        const env = { ...process.env };
        if (args.ght) {
          env.GITHUB_TOKEN = args.ght;
        }
        const child = exec(`gh api repos/${repo}/branches/${args.b} --jq .name`, 
          { timeout: 10000, env });
        
        child.on('close', (code) => {
          resolve({ code });
        });
        
        child.on('error', () => {
          resolve({ code: 1 });
        });
      });
      
      if (result.code !== 0) {
        throw new Error(`Branch '${args.b}' does not exist in ${repo}`);
      }
    }
  } catch (error) {
    if (error.message.includes('does not exist')) {
      throw error;
    }
    // For network errors or other issues, log warning but don't fail
    console.warn(`Warning: Could not validate GitHub resource: ${error.message}`);
  }
}

async function createSandbox(args) {
  try {
    // Validate arguments
    validateArgs(args);
    
    // Determine mode and sandbox name
    const isResumeMode = !!args.resume;
    let sandboxName;
    
    if (isResumeMode) {
      sandboxName = args.resume;
      console.log(`Resume mode: Using existing sandbox: ${sandboxName}`);
    } else {
      // Validate GitHub resources exist (only for new sandboxes)
      await validateGitHubResources(args);
      sandboxName = generateSandboxName(args);
      console.log(`Creating sandbox: ${sandboxName}`);
    }
    
    // Read file content for parameters that support files
    const prompt = readFileOrString(args.p);
    const mcpConfig = args.mc ? validateJsonContent(readFileOrString(args.mc), 'external MCP config (-mc)') : '';
    const agentsContent = args.ad ? processAgentsDirectory(args.ad) : '';
    const toolWhitelist = args.t ? validateJsonContent(readFileOrString(args.t), 'tool whitelist (-t)') : '';
    
    // Build sandbox creation command
    const template = args.template || 'claude-code-automation';
    let cmd = `cs sandbox create ${sandboxName} -t ${template}`;
    
    // Add pool option if specified
    if (args.pool) {
      cmd += ` --use-pool ${args.pool}`;
    }
    
    // Add environment variables
    const envVars = [];
    
    // GitHub integration variables
    if (args.r) {
      envVars.push(`-D 'claude/env[GITHUB_REPO]=${args.r}'`);
      // Only set GITHUB_TOKEN if explicitly provided (otherwise use Crafting credentials)
      if (args.ght) {
        envVars.push(`-D 'claude/env[GITHUB_TOKEN]=${args.ght}'`);
      }
      
      if (args.pr) {
        envVars.push(`-D 'claude/env[PR_NUMBER]=${args.pr}'`);
        envVars.push(`-D 'claude/env[ACTION_TYPE]=pr'`);
      } else if (args.i) {
        envVars.push(`-D 'claude/env[ISSUE_NUMBER]=${args.i}'`);
        envVars.push(`-D 'claude/env[ACTION_TYPE]=issue'`);
      } else if (args.b) {
        envVars.push(`-D 'claude/env[GITHUB_BRANCH]=${args.b}'`);
        envVars.push(`-D 'claude/env[ACTION_TYPE]=branch'`);
      }
    }
    
    // Sandbox lifecycle variables
    const shouldDelete = args.d.toLowerCase() === 'yes' ? 'true' : 'false';
    envVars.push(`-D 'claude/env[SHOULD_DELETE]=${shouldDelete}'`);
    
    // Debug mode variable
    const debugMode = args.debug && args.debug.toLowerCase() === 'yes' ? 'true' : 'false';
    envVars.push(`-D 'claude/env[DEBUG_MODE]=${debugMode}'`);
    
    // Custom repo path variable
    if (args.rp) {
      envVars.push(`-D 'claude/env[CUSTOM_REPO_PATH]=${args.rp}'`);
    }
    
    // Add Anthropic API key
    envVars.push(`-D 'claude/env[ANTHROPIC_API_KEY]=\${secret:shared/anthropic-apikey-eng}'`);
    
    // Disable all GitHub CLI interactive prompts
    envVars.push(`-D 'claude/env[GH_PROMPT_DISABLED]=1'`);
    
    if (envVars.length > 0) {
      cmd += ' \\\n  ' + envVars.join(' \\\n  ');
    }
    
    // Check for dry-run mode
    if (args.dryRun) {
      console.log(`\nüîç DRY RUN MODE - No actual sandbox creation or file transfers will occur\n`);
      
      if (isResumeMode) {
        console.log(`Resume mode: Would use existing sandbox: ${sandboxName}`);
      } else {
        console.log(`Executing sandbox creation command...`);
        console.log(`Command: ${cmd}`);
      }
      
      // Show what files would be transferred
      console.log(`Files that would be transferred:`);
      console.log(`  üìÑ Prompt ‚Üí /home/owner/cmd/prompt.txt`);
      if (mcpConfig) console.log(`  üìÑ External MCP config ‚Üí /home/owner/cmd/external_mcp.txt`);
      if (agentsContent) console.log(`  üìÑ Processed agents ‚Üí /home/owner/cmd/local_mcp_tools.txt`);
      if (toolWhitelist) console.log(`  üìÑ Tool whitelist ‚Üí /home/owner/cmd/tool_whitelist.txt`);
      
      console.log(`\n‚úÖ Parameter validation successful.`);
      console.log(`\nüöÄ Dry run complete. Remove --dry-run flag to ${isResumeMode ? 'resume sandbox' : 'create actual sandbox'}.`);
      return;
    }
    
    // Execute sandbox creation only if not in resume mode
    if (!isResumeMode) {
      console.log(`Executing sandbox creation command...`);
      console.log(`Command: ${cmd}`);
      
      await new Promise((resolve, reject) => {
        const child = exec(cmd, { timeout: 120000 });
        
        child.stdout.on('data', (data) => {
          process.stdout.write(data);
        });
        
        child.stderr.on('data', (data) => {
          process.stderr.write(data);
        });
        
        child.on('close', (code) => {
          if (code === 0) {
            console.log(`\nSandbox creation completed successfully`);
            resolve({ code });
          } else {
            console.error(`\nSandbox creation failed with exit code: ${code}`);
            reject(new Error(`Sandbox creation failed with exit code: ${code}`));
          }
        });
        
        child.on('error', (error) => {
          console.error(`\nSandbox creation failed: ${error.message}`);
          reject(error);
        });
      });
    } else {
      console.log(`Resume mode: Skipping sandbox creation, using existing sandbox: ${sandboxName}`);
    }
    
    console.log(`Sandbox is ready, proceeding with file transfers...`);
    
    // Generate task-specific file names for queue support
    let promptFileName = 'prompt.txt';  // Default for initial task
    if (isResumeMode) {
      // In resume mode, generate numbered prompt file for task queue
      // This will be handled by task state manager in start-worker.sh
      promptFileName = 'prompt_new.txt';  // Temporary file for new task
    }
    
    // Transfer files to sandbox
    await transferFile(prompt, sandboxName, `/home/owner/cmd/${promptFileName}`, 'prompt');
    
    if (mcpConfig) {
      await transferFile(mcpConfig, sandboxName, '/home/owner/cmd/external_mcp.txt', 'external MCP config');
    }
    
    if (agentsContent) {
      await transferFile(agentsContent, sandboxName, '/home/owner/cmd/local_mcp_tools.txt', 'processed agents');
    }
    
    if (toolWhitelist) {
      await transferFile(toolWhitelist, sandboxName, '/home/owner/cmd/tool_whitelist.txt', 'tool whitelist');
    }

    // BEGIN NEW SECTION: Transfer GitHub integration parameter files
    // Write GitHub repo
    if (args.r) {
      await transferFile(args.r, sandboxName, '/home/owner/cmd/github_repo.txt', 'GitHub repo');
    }

    // Write GitHub token (avoid echoing token in logs)
    if (args.ght) {
      await transferFile(args.ght, sandboxName, '/home/owner/cmd/github_token.txt', 'GitHub token');
    }
    // Write branch / PR / issue identifiers and action type
    const actionType = args.pr ? 'pr' : args.i ? 'issue' : args.b ? 'branch' : '';
    if (args.b) {
      await transferFile(args.b, sandboxName, '/home/owner/cmd/github_branch.txt', 'GitHub branch');
    }
    if (args.pr) {
      await transferFile(args.pr.toString(), sandboxName, '/home/owner/cmd/pr_number.txt', 'PR number');
    }
    if (args.i) {
      await transferFile(args.i.toString(), sandboxName, '/home/owner/cmd/issue_number.txt', 'Issue number');
    }
    if (actionType) {
      await transferFile(actionType, sandboxName, '/home/owner/cmd/action_type.txt', 'action type');
    }
    // END NEW SECTION

    // BEGIN TASK MANAGEMENT SECTION: Transfer task state information
    // Transfer task mode (resume vs create)
    const taskMode = isResumeMode ? 'resume' : 'create';
    await transferFile(taskMode, sandboxName, '/home/owner/cmd/task_mode.txt', 'task mode');
    
    // Transfer custom task ID if provided
    if (args.tid) {
      await transferFile(args.tid, sandboxName, '/home/owner/cmd/task_id.txt', 'custom task ID');
    }
    
    // Transfer original prompt filename for reference
    await transferFile(promptFileName, sandboxName, '/home/owner/cmd/prompt_filename.txt', 'prompt filename');
    // END TASK MANAGEMENT SECTION

    console.log(`\nüöÄ Sandbox "${sandboxName}" ${isResumeMode ? 'resumed' : 'created'} successfully with all configurations!`);
    
    // If debug mode is enabled, execute the worker and wait for completion
    if (args.debug && args.debug.toLowerCase() === 'yes') {
      console.log(`\nüîß DEBUG MODE: Starting worker execution and waiting for completion...`);
      
      const workerCmd = `cs exec -t -u 1000 -W ${sandboxName}/claude -- bash -i -c '~/claude/dev-worker/start-worker.sh'`;
      console.log(`Executing worker: ${workerCmd}`);
      console.log(`\nüì° REAL-TIME WORKER OUTPUT:\n${'='.repeat(80)}`);
      
      await new Promise((resolve, reject) => {
        const child = exec(workerCmd, { timeout: 1800000 }); // 30 minute timeout
        
        // Stream stdout in real-time with timestamps
        child.stdout.on('data', (data) => {
          const timestamp = new Date().toISOString().substring(11, 19);
          const lines = data.toString().split('\n');
          lines.forEach(line => {
            if (line.trim()) {
              console.log(`[${timestamp}] ${line}`);
            }
          });
        });
        
        // Stream stderr in real-time
        child.stderr.on('data', (data) => {
          const timestamp = new Date().toISOString().substring(11, 19);
          const lines = data.toString().split('\n');
          lines.forEach(line => {
            if (line.trim()) {
              console.error(`[${timestamp}] ERROR: ${line}`);
            }
          });
        });
        
        child.on('close', (code) => {
          console.log(`\n${'='.repeat(80)}`);
          if (code === 0) {
            console.log(`‚úÖ Worker execution completed successfully`);
            resolve({ code });
          } else {
            console.error(`‚ùå Worker execution failed with exit code: ${code}`);
            reject(new Error(`Worker execution failed with exit code: ${code}`));
          }
        });
        
        child.on('error', (error) => {
          console.log(`\n${'='.repeat(80)}`);
          console.error(`‚ùå Worker execution failed: ${error.message}`);
          reject(error);
        });
      });
      
    }
    
  } catch (error) {
    console.error(`‚ùå cs-cc failed: ${error.message}`);
    process.exit(1);
  }
}

// Main execution
async function main() {
  try {
    const args = parseArguments();
    
    if (args.help) {
      showHelp();
      process.exit(0);
    }
    
    await createSandbox(args);
    
  } catch (error) {
    console.error(`‚ùå ${error.message}`);
    process.exit(1);
  }
}

main(); 