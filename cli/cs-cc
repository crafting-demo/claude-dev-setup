#!/usr/bin/env node

import { readFileSync, existsSync, writeFileSync, unlinkSync } from 'node:fs';
import { exec } from 'node:child_process';
import { fileURLToPath } from 'node:url';
import { dirname, resolve, isAbsolute } from 'node:path';

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

function parseArguments() {
  const args = process.argv.slice(2);
  const parsed = { d: 'yes' }; // Set default for delete-when-done
  
  for (let i = 0; i < args.length; i++) {
    const arg = args[i];
    
    if (arg === '--help') {
      parsed.help = true;
      continue;
    }
    
    // Handle arguments that need values
    if (arg.startsWith('-') && i + 1 < args.length) {
      const value = args[i + 1];
      
      switch (arg) {
        case '-p':
        case '--prompt':
          parsed.p = value;
          i++;
          break;
        case '-pool':
          parsed.pool = value;
          i++;
          break;
        case '-r':
        case '--repo':
          parsed.r = value;
          i++;
          break;
        case '-ght':
        case '--github-token':
          parsed.ght = value;
          i++;
          break;
        case '-pr':
        case '--pull-request':
          parsed.pr = value;
          i++;
          break;
        case '-i':
        case '--issue':
          parsed.i = value;
          i++;
          break;
        case '-b':
        case '--branch':
          parsed.b = value;
          i++;
          break;
        case '-mc':
        case '--mcp-config':
          parsed.mc = value;
          i++;
          break;
        case '-lmc':
        case '--local-mcp-config':
          parsed.lmc = value;
          i++;
          break;
        case '-t':
        case '--tools':
          parsed.t = value;
          i++;
          break;
        case '-template':
        case '--template':
          parsed.template = value;
          i++;
          break;
        case '-d':
        case '--delete-when-done':
          parsed.d = value;
          i++;
          break;
        case '-n':
        case '--name':
          parsed.n = value;
          i++;
          break;
        case '--debug':
          parsed.debug = value;
          i++;
          break;
        default:
          throw new Error(`Unknown option: ${arg}`);
      }
    } else if (arg.startsWith('-')) {
      // Special case for dry-run flag that doesn't need a value
      if (arg === '--dry-run') {
        parsed.dryRun = true;
      } else {
        throw new Error(`Option ${arg} requires a value`);
      }
    } else {
      throw new Error(`Unexpected positional argument: ${arg}`);
    }
  }
  
  return parsed;
}

function showHelp() {
  console.log(`
cs-cc - Claude Sandbox Code CLI

Usage: cs-cc [options]

Options:
  -p, --prompt <value>           Prompt string or file path (required)
  -pool <name>                   Sandbox pool name (optional)
  -r, --repo <owner/repo>        GitHub repository (required for GitHub integration)
  -ght, --github-token <token>   GitHub access token (required for GitHub integration)
  -pr, --pull-request <number>   Pull request number (mutually exclusive with -i, -b)
  -i, --issue <number>           Issue number (mutually exclusive with -pr, -b)
  -b, --branch <name>            Branch name (mutually exclusive with -pr, -i)
  -mc, --mcp-config <value>      External MCP config string or file path (optional)
  -lmc, --local-mcp-config <value> Local MCP tools config string or file path (optional)
  -t, --tools <value>            Tool whitelist string or file path (optional)
  -template, --template <value>  Custom template name (default: claude-code-automation)
  -d, --delete-when-done <yes|no> Delete sandbox when done (default: yes)
  -n, --name <name>              Sandbox name (default: auto-generated)
  --debug <yes|no>               Debug mode: wait for worker completion and show all output (default: no)
  --dry-run                      Validate parameters and show commands without execution
  --help                         Show this help message

Examples:
  cs-cc -p "Fix the login bug" -r "owner/repo" -ght "ghp_token" -pr 123
  cs-cc -p prompt.txt -r "owner/repo" -ght "ghp_token" -i 456 -mc external_mcp.txt
  cs-cc -p "Implement feature" -pool my-pool -lmc local_tools.txt -t tool_whitelist.txt
  cs-cc -p "Debug workflow" -r "owner/repo" -ght "token" -b main --debug yes
  cs-cc -p "Custom workflow" -template my-template -r "owner/repo" -ght "token" -b main
`);
}

function readFileOrString(value) {
  if (!value) return '';
  
  // Check if it's a file path
  const isFile = value.includes('/') || value.includes('\\') || value.endsWith('.txt') || value.endsWith('.json');
  
  if (isFile) {
    const filePath = isAbsolute(value) ? value : resolve(process.cwd(), value);
    if (!existsSync(filePath)) {
      throw new Error(`File not found: ${filePath}`);
    }
    return readFileSync(filePath, 'utf8').trim();
  }
  
  return value;
}

function validateJsonContent(content, parameterName) {
  if (!content) return content;
  
  try {
    JSON.parse(content);
    return content;
  } catch (error) {
    throw new Error(`Invalid JSON in ${parameterName}: ${error.message}`);
  }
}



function validateArgs(args) {
  const errors = [];
  
  // Validate required parameters
  if (!args.p) {
    errors.push('Prompt (-p) is required');
  }
  
  // Validate mutually exclusive GitHub parameters
  const githubParams = [args.pr, args.i, args.b].filter(Boolean);
  if (githubParams.length > 1) {
    errors.push('Only one of -pr, -i, or -b can be specified');
  }
  
  // Validate GitHub integration parameters
  if (args.r || args.ght || githubParams.length > 0) {
    if (!args.r) {
      errors.push('GitHub repo is required when using GitHub integration');
    } else {
      // Validate GitHub repository format (owner/repo)
      const repoPattern = /^[a-zA-Z0-9._-]+\/[a-zA-Z0-9._-]+$/;
      if (!repoPattern.test(args.r)) {
        errors.push('Invalid repo format - must be in format owner/repo');
      }
    }
    if (!args.ght) errors.push('GitHub token is required when using GitHub integration');
    if (githubParams.length === 0) {
      errors.push('One of -pr, -i, or -b must be specified when using GitHub integration');
    }
  }
  
  // Validate delete-when-done parameter
  if (args.d && !['yes', 'no'].includes(args.d.toLowerCase())) {
    errors.push('Delete when done (-d) must be "yes" or "no"');
  }
  
  // Validate debug parameter
  if (args.debug && !['yes', 'no'].includes(args.debug.toLowerCase())) {
    errors.push('Debug mode (--debug) must be "yes" or "no"');
  }
  
  if (errors.length > 0) {
    throw new Error('Validation errors:\n' + errors.map(e => `  - ${e}`).join('\n'));
  }
}

function generateSandboxName(args) {
  if (args.n) {
    return args.n;
  }
  
  // Use existing naming logic from agent.js with sanitization
  const repoName = args.r ? args.r.split('/')[1] || 'repo' : 'sandbox';
  const timestamp = Date.now().toString().slice(-4);
  const itemNumber = args.pr || args.i || 'dev';
  
  // Sanitize repo name - replace invalid characters with hyphens and ensure valid format
  const sanitizedRepoName = repoName
    .substring(0, 8)
    .replace(/[^a-z0-9-]/gi, '-')  // Replace invalid chars with hyphens
    .replace(/^[^a-z]/i, 'a')      // Ensure starts with letter
    .replace(/[^a-z0-9]$/i, '9')   // Ensure ends with letter or number
    .toLowerCase();
  
  const sandboxName = `cw-${sanitizedRepoName}-${itemNumber}-${timestamp}`.substring(0, 20);
  
  return sandboxName;
}

async function transferFile(content, sandboxName, targetPath, description) {
  if (!content) return;

  const tempFile = `./temp_${Date.now()}.txt`;

  try {
    writeFileSync(tempFile, content, 'utf8');

    const remoteDir = dirname(targetPath);
    const mkdirCmdBase = `cs exec -t -u 1000 -W ${sandboxName}/claude -- mkdir -p ${remoteDir}`;
    const scpCmdBase   = `cs scp ${tempFile} ${sandboxName}/claude:${targetPath}`;

    // Helper to run a shell command with retries
    const runWithRetries = (cmd, maxRetries = 5, delayMs = 5000) => new Promise((resolve, reject) => {
      let attempt = 0;
      const run = () => {
        console.log(`Attempt #${attempt+1}: ${cmd}`);
        const child = exec(cmd, { timeout: 60000 });
        child.on('close', (code) => {
          if (code === 0) return resolve();
          if (++attempt >= maxRetries) return reject(new Error(`Command failed after ${maxRetries} attempts (exit ${code})`));
          console.warn(`Command failed (exit ${code}) – retrying in ${delayMs/1000}s...`);
          setTimeout(run, delayMs);
        });
        child.on('error', (err) => {
          if (++attempt >= maxRetries) return reject(err);
          console.warn(`Command error: ${err.message} – retrying in ${delayMs/1000}s...`);
          setTimeout(run, delayMs);
        });
      };
      run();
    });

    console.log(`Ensuring remote directory exists: ${remoteDir}`);
    await runWithRetries(mkdirCmdBase);

    console.log(`Transferring ${description} to sandbox path: ${targetPath}`);
    await runWithRetries(scpCmdBase);

    console.log(`${description} transfer completed successfully`);
  } finally {
    try { unlinkSync(tempFile); } catch {}
  }
}

async function validateGitHubResources(args) {
  // Only validate if GitHub integration is being used
  if (!args.r || !args.ght) return;
  
  const repo = args.r;
  
  try {
    if (args.pr) {
      // Validate PR exists using gh CLI
      const result = await new Promise((resolve) => {
        const child = exec(`gh pr view ${args.pr} --repo ${repo}`, 
          { timeout: 10000, env: { ...process.env, GITHUB_TOKEN: args.ght } });
        
        child.on('close', (code) => {
          resolve({ code });
        });
        
        child.on('error', (error) => {
          resolve({ code: 1 });
        });
      });
      
      if (result.code !== 0) {
        throw new Error(`Pull request #${args.pr} does not exist in ${repo}`);
      }
    } else if (args.i) {
      // Validate issue exists using gh CLI
      const result = await new Promise((resolve) => {
        const child = exec(`GITHUB_TOKEN=${args.ght} gh issue view ${args.i} --repo ${repo} --json number`, 
          { timeout: 10000 });
        
        child.on('close', (code) => {
          resolve({ code });
        });
        
        child.on('error', () => {
          resolve({ code: 1 });
        });
      });
      
      if (result.code !== 0) {
        throw new Error(`Issue #${args.i} does not exist in ${repo}`);
      }
    } else if (args.b) {
      // Validate branch exists using gh CLI
      const result = await new Promise((resolve) => {
        const child = exec(`GITHUB_TOKEN=${args.ght} gh api repos/${repo}/branches/${args.b} --jq .name`, 
          { timeout: 10000 });
        
        child.on('close', (code) => {
          resolve({ code });
        });
        
        child.on('error', () => {
          resolve({ code: 1 });
        });
      });
      
      if (result.code !== 0) {
        throw new Error(`Branch '${args.b}' does not exist in ${repo}`);
      }
    }
  } catch (error) {
    if (error.message.includes('does not exist')) {
      throw error;
    }
    // For network errors or other issues, log warning but don't fail
    console.warn(`Warning: Could not validate GitHub resource: ${error.message}`);
  }
}

async function createSandbox(args) {
  try {
    // Validate arguments
    validateArgs(args);
    
    // Validate GitHub resources exist
    await validateGitHubResources(args);
    
    // Read file content for parameters that support files
    const prompt = readFileOrString(args.p);
    const mcpConfig = args.mc ? validateJsonContent(readFileOrString(args.mc), 'external MCP config (-mc)') : '';
    const localMcpConfig = args.lmc ? validateJsonContent(readFileOrString(args.lmc), 'local MCP config (-lmc)') : '';
    const toolWhitelist = args.t ? validateJsonContent(readFileOrString(args.t), 'tool whitelist (-t)') : '';
    
    // Generate sandbox name
    const sandboxName = generateSandboxName(args);
    console.log(`Creating sandbox: ${sandboxName}`);
    
    // Build sandbox creation command
    const template = args.template || 'claude-code-automation';
    let cmd = `cs sandbox create ${sandboxName} -t ${template}`;
    
    // Add pool option if specified
    if (args.pool) {
      cmd += ` --use-pool ${args.pool}`;
    }
    
    // Add environment variables
    const envVars = [];
    
    // GitHub integration variables
    if (args.r && args.ght) {
      envVars.push(`-D 'claude/env[GITHUB_REPO]=${args.r}'`);
      envVars.push(`-D 'claude/env[GITHUB_TOKEN]=${args.ght}'`);
      
      if (args.pr) {
        envVars.push(`-D 'claude/env[PR_NUMBER]=${args.pr}'`);
        envVars.push(`-D 'claude/env[ACTION_TYPE]=pr'`);
      } else if (args.i) {
        envVars.push(`-D 'claude/env[ISSUE_NUMBER]=${args.i}'`);
        envVars.push(`-D 'claude/env[ACTION_TYPE]=issue'`);
      } else if (args.b) {
        envVars.push(`-D 'claude/env[GITHUB_BRANCH]=${args.b}'`);
        envVars.push(`-D 'claude/env[ACTION_TYPE]=branch'`);
      }
    }
    
    // Sandbox lifecycle variables
    const shouldDelete = args.d.toLowerCase() === 'yes' ? 'true' : 'false';
    envVars.push(`-D 'claude/env[SHOULD_DELETE]=${shouldDelete}'`);
    
    // Debug mode variable
    const debugMode = args.debug && args.debug.toLowerCase() === 'yes' ? 'true' : 'false';
    envVars.push(`-D 'claude/env[DEBUG_MODE]=${debugMode}'`);
    
    // Add Anthropic API key
    envVars.push(`-D 'claude/env[ANTHROPIC_API_KEY]=\${secret:shared/anthropic-apikey-eng}'`);
    
    // Disable all GitHub CLI interactive prompts
    envVars.push(`-D 'claude/env[GH_PROMPT_DISABLED]=1'`);
    
    if (envVars.length > 0) {
      cmd += ' \\\n  ' + envVars.join(' \\\n  ');
    }
    
    console.log(`Executing sandbox creation command...`);
    console.log(`Command: ${cmd}`);
    
    // Check for dry-run mode
    if (args.dryRun) {
      console.log(`\n🔍 DRY RUN MODE - No actual sandbox creation or file transfers will occur\n`);
      
      // Show what files would be transferred
      console.log(`Files that would be transferred:`);
      console.log(`  📄 Prompt → /home/owner/cmd/prompt.txt`);
      if (mcpConfig) console.log(`  📄 External MCP config → /home/owner/cmd/external_mcp.txt`);
      if (localMcpConfig) console.log(`  📄 Local MCP tools → /home/owner/cmd/local_mcp_tools.txt`);
      if (toolWhitelist) console.log(`  📄 Tool whitelist → /home/owner/cmd/tool_whitelist.txt`);
      
      console.log(`\n✅ Parameter validation successful. Command would execute: ${cmd}`);
      console.log(`\n🚀 Dry run complete. Remove --dry-run flag to create actual sandbox.`);
      return;
    }
    
    // Execute sandbox creation
    await new Promise((resolve, reject) => {
      const child = exec(cmd, { timeout: 120000 });
      
      child.stdout.on('data', (data) => {
        process.stdout.write(data);
      });
      
      child.stderr.on('data', (data) => {
        process.stderr.write(data);
      });
      
      child.on('close', (code) => {
        if (code === 0) {
          console.log(`\nSandbox creation completed successfully`);
          resolve({ code });
        } else {
          console.error(`\nSandbox creation failed with exit code: ${code}`);
          reject(new Error(`Sandbox creation failed with exit code: ${code}`));
        }
      });
      
      child.on('error', (error) => {
        console.error(`\nSandbox creation failed: ${error.message}`);
        reject(error);
      });
    });
    
    console.log(`Sandbox is ready, proceeding with file transfers...`);
    
    // Transfer files to sandbox
    await transferFile(prompt, sandboxName, '/home/owner/cmd/prompt.txt', 'prompt');
    
    if (mcpConfig) {
      await transferFile(mcpConfig, sandboxName, '/home/owner/cmd/external_mcp.txt', 'external MCP config');
    }
    
    if (localMcpConfig) {
      await transferFile(localMcpConfig, sandboxName, '/home/owner/cmd/local_mcp_tools.txt', 'local MCP tools');
    }
    
    if (toolWhitelist) {
      await transferFile(toolWhitelist, sandboxName, '/home/owner/cmd/tool_whitelist.txt', 'tool whitelist');
    }

    // BEGIN NEW SECTION: Transfer GitHub integration parameter files
    // Write GitHub repo
    if (args.r) {
      await transferFile(args.r, sandboxName, '/home/owner/cmd/github_repo.txt', 'GitHub repo');
    }
    // Write GitHub token (avoid echoing token in logs)
    if (args.ght) {
      await transferFile(args.ght, sandboxName, '/home/owner/cmd/github_token.txt', 'GitHub token');
    }
    // Write branch / PR / issue identifiers and action type
    const actionType = args.pr ? 'pr' : args.i ? 'issue' : args.b ? 'branch' : '';
    if (args.b) {
      await transferFile(args.b, sandboxName, '/home/owner/cmd/github_branch.txt', 'GitHub branch');
    }
    if (args.pr) {
      await transferFile(args.pr.toString(), sandboxName, '/home/owner/cmd/pr_number.txt', 'PR number');
    }
    if (args.i) {
      await transferFile(args.i.toString(), sandboxName, '/home/owner/cmd/issue_number.txt', 'Issue number');
    }
    if (actionType) {
      await transferFile(actionType, sandboxName, '/home/owner/cmd/action_type.txt', 'action type');
    }
    // END NEW SECTION

    console.log(`\n🚀 Sandbox "${sandboxName}" created successfully with all configurations!`);
    
    // If debug mode is enabled, execute the worker and wait for completion
    if (args.debug && args.debug.toLowerCase() === 'yes') {
      console.log(`\n🔧 DEBUG MODE: Starting worker execution and waiting for completion...`);
      
      const workerCmd = `cs exec -t -u 1000 -W ${sandboxName}/claude -- bash -i -c '~/claude/dev-worker/start-worker.sh'`;
      console.log(`Executing worker: ${workerCmd}`);
      console.log(`\n📡 REAL-TIME WORKER OUTPUT:\n${'='.repeat(80)}`);
      
      await new Promise((resolve, reject) => {
        const child = exec(workerCmd, { timeout: 1800000 }); // 30 minute timeout
        
        // Stream stdout in real-time with timestamps
        child.stdout.on('data', (data) => {
          const timestamp = new Date().toISOString().substring(11, 19);
          const lines = data.toString().split('\n');
          lines.forEach(line => {
            if (line.trim()) {
              console.log(`[${timestamp}] ${line}`);
            }
          });
        });
        
        // Stream stderr in real-time
        child.stderr.on('data', (data) => {
          const timestamp = new Date().toISOString().substring(11, 19);
          const lines = data.toString().split('\n');
          lines.forEach(line => {
            if (line.trim()) {
              console.error(`[${timestamp}] ERROR: ${line}`);
            }
          });
        });
        
        child.on('close', (code) => {
          console.log(`\n${'='.repeat(80)}`);
          if (code === 0) {
            console.log(`✅ Worker execution completed successfully`);
            resolve({ code });
          } else {
            console.error(`❌ Worker execution failed with exit code: ${code}`);
            reject(new Error(`Worker execution failed with exit code: ${code}`));
          }
        });
        
        child.on('error', (error) => {
          console.log(`\n${'='.repeat(80)}`);
          console.error(`❌ Worker execution failed: ${error.message}`);
          reject(error);
        });
      });
      
    }
    
  } catch (error) {
    console.error(`❌ cs-cc failed: ${error.message}`);
    process.exit(1);
  }
}

// Main execution
async function main() {
  try {
    const args = parseArguments();
    
    if (args.help) {
      showHelp();
      process.exit(0);
    }
    
    await createSandbox(args);
    
  } catch (error) {
    console.error(`❌ ${error.message}`);
    process.exit(1);
  }
}

main(); 